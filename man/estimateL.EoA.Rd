% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/estimateL.EoA.R
\name{estimateL.EoA}
\alias{estimateL.EoA}
\title{estimateL.EoA - Estimate rate parameter Lambda for
a single-site using the classic EoA method}
\usage{
estimateL.EoA(
  X,
  beta.params,
  Lprior = "jeffreys",
  Lprior.mean = NULL,
  Lprior.sd = NULL,
  conf.level = 0.9
)
}
\arguments{
\item{X}{Total number of search targets found at all searched sites during the
entire search season.}

\item{beta.params}{A list containing, at a minimum, components named $alpha and $beta.
These are the all-site alpha and beta parameters for g. In many cases, these parameters
are computed using function \code{\link{getFleetG}}.}

\item{Lprior}{A string naming the prior distribution to use for lambda.
The following priors are implimented:
\enumerate{
   \item "normal" : uses a normal(\code{Lprior.mean},\code{Lprior.sd}) prior for lambda.
   \item "gamma" : uses a gamma(alpha,beta) prior for lambda, where alpha =
\code{Lprior.mean^2}/\code{Lprior.sd^2} and beta = \code{Lprior.mean}/
\code{Lprior.sd^2}. That is, alpha and beta are the method of moment estimates
for the shape and rate parameter of a gamma distribution.
   \item "jefferys" : uses a beta(L + 0.5, 0.5) function as the prior for lambda.  This prior
   is improper and really close to the actual Jeffery's prior for a poisson random variable.
   This is the Jeffery's prior implemented by Dalthorp's eoa package.
}}

\item{Lprior.mean}{Mean of lambda prior when Lprior == "normal" or "gamma".}

\item{Lprior.sd}{Standard deviation of normal when Lprior == "normal" or "gamma".}

\item{conf.level}{Confidence level for the confidence intervals on lambda.}
}
\value{
List containing two components:
\itemize{
  \item  \code{$L.ests} is a data
frame containing the lambda estiamtes (point estimate and confidence interval).
  \item \code{$L.posterior} is a data frame containing the
  posterior, posterior cdf, prior, and likelihood. This is returned in case
  you want to plot them.
}
}
\description{
This routine computes lambda, the mean number of search targets
out there per season,
using information from the number of found targets and the g-value (=probatility of
discovery).  This differs from the \code{eoar()} function in that
this routine does not allow covariates (mean model only).
The method is Bayesian and allows either an uniform prior for lambda
or an informed prior.
Estimation is direct in the sense that this routine uses numerical
integration to compute the posterior of lambda.
}
\examples{

syr <- data.frame(species=c("LBBA","LBBA","LBBA"),
   facility=c("f1","f2","f2"),
   gFac.a = c( 69.9299, 63.5035,  84.6997),
   gFac.b = c(  736.4795,  318.3179, 759.9333 ),
   year = c(2015,2015,2016))
g <- getFleetG(syr, "LBBA"))

eoa <- estimateL.EoA( 1, g )  # Un-informed EoA

ieoa <- estimateL.EoA( 1, g, Lprior="normal", Lprior.mean=20, Lprior.sd=4) # Informed EoA

# interesting plot showing movement of posterior
plot(ieoa$L.posterior$L, ieoa$L.posterior$pdf, type="l")
lines(ieoa$L.posterior$L, ieoa$L.posterior$like.pdf, col="red")
lines(ieoa$L.posterior$L, ieoa$L.posterior$prior.pdf, col="blue")
legend("topright", legend=c("prior","likelihood","posterior"), col=c("blue","red","black"), lty=1)

# to check that integral is correct.
flike <- function(x, est){
  approx(est$L.posterior$L, est$L.posterior$like.pdf,xout=x, rule=2)$y
  }
integrate( flike, min(ieoa$L.posterior$L), max(ieoa$L.posterior$L), est=ieoa)

}
